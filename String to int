#Recibe en el registro ESI el string
string_to_int:
 	 xor ebx,ebx    ; clear ebx 
	.next_digit:
 		 movzx eax,byte[esi]
  		 inc esi
 		 sub al,'0'    ; convert from ASCII to number
 		 imul ebx,10
 		 add ebx,eax   ; ebx = ebx*10 + eax
 		 cmp byte[esi+1],0h
                 jne .next_digit 
 		 mov eax,ebx

Como no se que tanto sabe de Nasm le explicaré el codigo
-Hacer xor del mismo registro limpia el registro (lo pone en 0 todo)
-.next_digit: es una sub-etiqueta de string_to_int: (es como hacer una pequeña función dentro de la etiqueta principal)
- movzx: la etiqueta mov permite mover la información de un registro o buffer a otro registro siempre y cuando fueran del mismo tamaño tanto como en el que envía como el que recibe, ahora movzx permite que mover la información de uno más pequeño a otro más grande en este caso mueve un byte(8 bits) a un registro de 32 bits (En 64 bits tengo entendido que NO se puede mover de 8bits a 64bits, solo de 16bits y 32bits a 64bits)
- inc: incrementar
-sub: resta
-imul: multiplicacion con signo
-add: suma
-cmp: compara
El secreto está en restarle ‘0’ para convertirlo en numero y sumarle ‘0’  para pasarlo a ascii
